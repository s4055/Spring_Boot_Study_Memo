------------------------------------ Rest ------------------------------------
(1) Client, Server : 클라이너트와 서버가 서로 독립적으로 분리
(2) Stateless : 요청에 대해서 클라이언트의 상태를서버에 저장하지 않음
(3) Cache : 클라이언트는 서버의 응답을 Cache(임시저장) 할 수 있어야한다.
		클라이언트가 Cache를 통해서 응답을 재사용할 수 있어야 하며 이를 통해서 서버의 부하를 낮춤
(4) 계층화(Layer System) : 서버와 클라이언트 사이에 방화벽, 게이트웨이, Proxy 등 다양한 계층 형태로 구성이 가능해야하며 이를 확장할 수 있어야한다.
(5) 인터페이스 일관성 : 인터페이스의 일관성을 지키고 아키텍처를 단수화시켜 작은 단위로 분리하여 클라이언트, 서버가 독립적으로 개선 될 수 있어야함
(6) Code on Demand(Optional) : 자바 애플릿, 자바스크립트, 플래시 등 특정한 기능을 서버로 부터 클라이언트가 전달받아 코드를 실행할 수 있어야함

------------------------------------ 인터페이스의 일관성 ------------------------------------

(1) 자원의 식별
웹 기반의 REST에서는 리소스 접근을 할 때 URI를 사용
http://foo.co.kr/user/100
Resource : user
식별자 : 100

(2) 메시지를 통한 리소스 조작
Web에서는 다양한 방식으로 데이터를 전달할 수 있음 -> HTML, XML, JSON, TEXT
이 중에서 어떠한 타입의 데이터인지를 알려주기 위해서 HTTP Header부분에 context-type을 통해서 데이터의 타입을 지정해 줄 수 있음

(3) 자기서술적 메시지
요청하는 데이터가 어떻게 처리 되어져야 하는지 충분한 데이터를 포함할 수 있어야함
GET : READ
POST : CREAD
PUT : UPDATE
DELETE : DELETE

(4) Application 상태에 대한 엔진으로써 하이퍼미디어
REST API를 개발할 때 단순히 Client 요청에 대한 데이터만 응답해주는 것이 아닌 관련된 리소스에 대한 Link 정보가지 같이 포함되어져야함

------------------------------------ URI 설계 패턴 ------------------------------------
(1) URI
인터넷에서 특정 자원을 나타내는 주소값, 해당 값은 유일함

(2) URL
인터넷상에서의 자원, 특정 파일이 어디에 위치하는지 식별하는 주소

URI > URL

(1) URI 설계 원칙(RFC 3986)
- 슬래시(/) 계층 관계를 나타내는데 사용
- URI 마지막 문자로(/) 포함 X
- 하이픈(-)은 URI 가독성을 높이는데 사용
- 밑줄(_) 사용하지 않음
- URI 경로에는 소문자
- 파일 확장자는 URI에 포함하지 않음
- 프로그래밍 언어에 의존적인 확장자를 사용하지 않음
	-> EX) ~/insert.do
- 구현에 의존적인 경로를 사용하지 않음
	-> EX) ~/servlet/
- 세션ID 포함하지 않음
	-> EX) ~?session-id=abd
- 프로그래밍 언어의 Method명을 이용하지 않음
- 명사에 단수형보다는 복수형을 사용, 컬렉션에 대한 표현은 복수롤 사용
- 컨트롤러 이름으로는 동사나 동사구를 사용
- 경로 부분 중 변하는 부분은 유일한 값으로 대체
- CRUD 기능을 나타내는 것은 URI에 사용하지 않음
- URI Query Parameter 디자인, URI 쿼리 부분으로 컬렉션 결과에 대해서 필터링 할 수 있음
- URI 쿼리는 컬렉션의 결과를 페이지로 구분하여 나타내는데 사용
- API에 있어서 서브 도메인은 일관성있게 사용
- 클라이언트 개발자 포탈 서브 도메인은 일관성 있게 만듬


------------------------------------ JSON ------------------------------------
string : value
number : value
boolean : value
object : value {}
array : value []

{
	"phone_number" : "010-1111-2222",	<- string
	"age" : 20,				<- number
	"isAgree" : false,			<- boolean
	"account" : {				<- object
		"email" : "steve@gmail.com",
		"password" : "1234"
	}
}

// user 조회 하는 경우
{
	"user_list" : [				<- array
		{
			"account" : "abcd",
			"password" : "1234"		
		},
		{
			"account" : "aaaa",
			"password" : "1111"		
		},
		{
			"account" : "bbbb",
			"password" : "2222"		
		}
	]
}

------------------------------------ AOP ------------------------------------
스프링 어플리케이션은 대부분 특별한 경우를 제외하고는 MVC 웹 어플리케이션에서는 Web Layer, Business Layer, Data Layer로 정의
Web Layer : REST API를 제공, Client 중심의 로직 적용
Business Layer : 내부 정책에 따른 logic을 개발, 주로 해당 부분을 개발
Data Layer : 데이터베이스 및 외부와의 연동을 처리

------------------------------------ Filter ------------------------------------
Web Application에서 관리되는 영역으로써 Spring Boot Framework에서 Client로 부터 오는 요청/응답에 대해서 최초/최종 단계의 위치에 존재하며
이를 통해서 요청/응답의 정보를 변경하거나 Spring에 의해서 데이터가 변환되기 전의 순수한 Client의 요청/응답 값을 확인할 수 있다.

유일하게 ServletRequest, ServletResponse의 객체를 변환할 수 있음

주로 request/response의 Logging용도로 활용하거나, 인증과 관련된 Logic들을 해당 Filter에서 처리

이를 서/후 처리 함으로써 Service business logic과 분리

------------------------------------ JUnit ------------------------------------
- TOD
테스트 주도 개발에서 사용하지만 코드의 유지보수 및 운영환경에서의 에러를 미리 방지하기 위해서 단위별로 검증하는 테스트 프레임워크

- 단위테스트
작성한 코드가 기대하는대로 동작을 하는지 검증하는 절차

- JUnit
Java기반의 단위테스트를 위한 프레임워크
Annotation 기반으로 테스트를 지원하며, Assert를 통하여 (예상, 실제)를 통해 검증

- Jacoco
Java코드의 코드 버러리지를 체크하는 라이브러리
결과를 html, xml, csv로 확인 가능

------------------------------------ 스프링 배치 ------------------------------------
- 큰 단위의 작업을 일괄 처리
- 대부분 처리량이 많고 비 실시간성 처리에 사용
	- 대용량 데이터 계산, 정산, 통계 데이터베이스, 변환등
- 컴퓨터 자원을 최대로 활용
	- 컴퓨터 자원 사용이 낮은 시간대에 배치를 처리하거나 배치만 처리하기 위해 사용자가 사용하지 않는 또 다른 컴퓨터 자원을 사용
- 사용자 상호작용으로 실해되기 보단, 스케줄러와 같은 시스템에 의해 실행되는 대상
	- 예를 들면 매일 오전 10시 배치실행, 매주 월요일 12 마다 실행 : crontab, jenkins...
- 배치 처리를 하기 위한 Spring Framework 기반 기술
	- Spring에서 지원하는 기술 적용 가능
	- DI, AOP, 서비스 추상화
- 스프링 배치의 실행 단위는 Job과 Step
- 비교적 간단한 작업(Tasklet) 단위 처리와, 대량 묶음(Chunk) 단위 처리

------------------------------------ Interceptor ------------------------------------
Filter와 매우 유사한 형태로 존재, 차이점은 Spring Context에 등록
AOP와 유사한 기능을 제공할 수 있으며 주로 인증 단계를 처리하거 Logginf를 하는데에 사용
이를 선/후 처리함으로써 Service bussiness logic과 분리

------------------------------------ JPA ------------------------------------
ORM : 객체와 데이터베이스 사이의 관계를 매핑
	- 어플리케이션과 데이터베이스를 연결해주는 것
JPA : 자바에서 ORM의 표준으로 JPA
하이버네이트 : 실제 JPA의 구현체 클래스를 모아놓은 것
Spring Data JPA : 자주 사용하는 기술들을 다시 스프링 프레임워크에서 묶어서 정의한 것

------------------------------------ Entity ------------------------------------
@GenerationType
- TABLE : Id 값을 관리하는 테이블을 생성하여 관리
- SEQUENCE : Oracle
- IDENTITY : MySQL, Maria
- AUTO : 각 DB에 맞는 전략을 찾아서 생성

@Transient : DB에 반영하지 않고 사용하고 싶은 경우, 영속성 처리에서 제외, 해당 객체와 생명주기를 같이 사용

------------------------------------ 스프링 시큐리티 ------------------------------------
- 스프링 시큐리티가 필요한 이유
웹사이트는 각종 서비스를 하기 위한 리소스와 서비스를 사용하는 유저들의 개인 정보를 가지고 있다. 
이들 리소스를 보호하기 위해서 일반적으로 웹사이트는 두 가지 보안 정책을 설정해야한다.
1. 서버 리소스
2. 유저들의 개인 정보

- 인증 (Authentication)
사이트에 접근하는 사람이 누구인지 시스템이 알아야한다.
# UsernamePassword 인증
	1. Session 관리
	2. 토큰 관리
# SNS 로그인(소셜로그인) : 인증 위임

- 인가 혹은 권한 (Authorization)
사용자가 누구인지 알았다면 사이트 관리자 혹은 시스템은 로기인한 사용자가 어떤 일을 할 수 있는지 권한을 설정한다.
권한은 특정 페이지에 접근하거나 특정 리소스에 접근할 수 있는 권한여부를 판단하는데 사용된다.
1. Secured : deprecated
2. PrePostAuthorize
3. AOP

- 필터와 필터 사이에 Proxy(대리자)를 두어 어떤 시큐리티를 적용할지 선택
- 인증 토큰(Authentication)을 제공하는 필터들
1. UsernamePasswordAuthenticationFilter : 폼 로그인 -> UsernamePasswordAuthenticationToken
2. RememberMeAuthenticationFilter : remember-me 쿠키 로그인 -> RememberMeAuthenticationToken
3. AnonymousAuthenticationFilter : 로그인하지 않았다는 것을 인증함 -> AnonymousAuthenticationToken
4. SecurityContextPersistenceFilter : 기존 로그인을 유지함(기본적으로 session 을 이용함)
5. BearerTokenAuthenticationFilter : JWT 로그인 세션을 사용하지 않은 경우 
	토큰에 많은 정보를 담아야하기 때문에 사용
6. BasicAuthenticationFilter : ajax 로그인 -> UsernamePasswordAuthenticationToken, 
	아이디와 비밀번호를 Base64로 인코딩하여 보내주면 필터에서 로그인 인증을 하고 바로 요청하는 페이지로 보내줌 
	세션을 사용하는 경우에만 사용
	Ex) 로그인 페이지가 따로 필요없는 모바일에서 사용
7. OAuth2LoginAuthenticationFilter : 소셜 로그인 -> OAuth2LoginAuthenticationToken, OAuth2AuthenticationToken
8. OpenIDAuthenticationFilter : OpenID 로그인
9. Saml2WebSsoAuthenticationFilter : SAML2 로그인
10. ... 기타

 - JWT 토큰
서버에서 인증된 사용자가 인증을 유지해주는 방법으로 보통은 세션을 사용합니다. 서버 세션을 사용하면 인증된 사용자는 매우 편리하게 서비스를 이용할 수 있고 대부분의 웹 애플리케이션 서버가 세션을 지원하기 때문에 편리합니다.

하지만 {여러대 둘 경우(scale out), 같은 사용자가 서돌 다른 도메인의 데이터를 요청할 경우 (SSO)에는 세션을 유지하기 위한 비용이 매우 커지게 됩니다}

이 때는 서버에 사용자 정보을 저장하는 대신 클라이언트에 사용자 정보를 내려주고 서버는 토큰의 사용자 정보를 모든 요청에서 확인하고 서비스를 해주는 방식(sessionless)일 때, JWT 토큰이 유용하게 사용됩니
JWT 자바 라이브러리는 보통 auth0.com에서 만든 java-jwt 라이브러리를 쓰거나 okta에서 만든 jjwt 라이브러리를 사용합니다.

페일로드 부분에 키:값 형태로 서버가 주면 클라이언트가 가지고 있다가 요청할 때마다 서버가 토큰을 비교하여 서비스를 제공

Auth Toke을 사용하여 사용자 인증 : 만료 시간을 두어 인증 시간을 정함
자동 로그인을 위해 Refresh Token을 사용 : 클라이언트가 가지고 있기 때문에 보안을 생각한다면 서버에서 DB로 관리가 필요함

- JWT 어떤 내용을 넣어야 할까?
일반적으로는 인증에 필요한 최소한의 데이터를 넣음
비밀번호나 전화번호등을 넣는 것은 안전하지 않음
이 토큰은 언제든 공개할 수 있는 정보를 넣는 것이 좋음
서버에서 인증된 키가 아니라도 언제든 서버는 이 토큰을 열어서 그 안에 어떤 Claim이 있는지 볼 수 있음

- JWT 토큰을 어떻게 관리할 것인가?
이론적으로 토큰을 클라이언트가 관리
하지만 실제로 서버는 사용자 정보 캐싱이나 토큰의 유효성 평가, 혹은 refresh토큰 정책을 위해 서버에 토큰을 관리하기도 함
이 경우, 토큰과 사용자 정보를 관리하는 방법으로 {(redis, hazelcast), DB 저장}을 사용
# redis, hazelcast : 사용자의 정보를 매번 DB에서 가져오는 것이 힘들기 때문에 사용자의 정보를 가지고 있게 하여 세션처럼 사용, 여러대의 서버에 올려서 사용할 수 있는 장점이 있음





















































